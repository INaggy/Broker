{
  "name": "Neo4jSinkConnector",
  "config": {
    "topics": "postgres_server.public.university,postgres_server.public.institute,postgres_server.public.department,postgres_server.public.specialty,postgres_server.public.st_group,postgres_server.public.course_of_lecture,postgres_server.public.lecture,postgres_server.public.material_of_lecture,postgres_server.public.students,postgres_server.public.schedule",
    "connector.class": "streams.kafka.connect.sink.Neo4jSinkConnector",
    "key.converter": "org.apache.kafka.connect.storage.StringConverter",
    "key.converter.schemas.enable": "false",
    "value.converter": "org.apache.kafka.connect.json.JsonConverter",
    "value.converter.schemas.enable": "false",
    "errors.tolerance": "all",
    "errors.log.enable": "true",
    "errors.log.include.messages": "true",
    "neo4j.server.uri": "bolt://neo4j:7687",
    "neo4j.authentication.basic.username": "neo4j",
    "neo4j.authentication.basic.password": "strongpassword",
    "neo4j.topic.cypher.postgres_server.public.university": "CALL apoc.do.case([ event.op = 'c', 'MERGE (u:University {id: event.after.id}) SET u.name = event.after.name, u.location = event.after.location', event.op = 'd', 'MATCH (u:University {id: event.before.id}) DETACH DELETE u', event.op = 'u', 'MATCH (u:University {id: event.after.id}) SET u.name = event.after.name, u.location = event.after.location' ], '', {event: event}) YIELD value as university RETURN university",
    "neo4j.topic.cypher.postgres_server.public.institute": "CALL apoc.do.case([ event.op = 'c', 'MERGE (i:Institute {id: event.after.id}) SET i.name = event.after.name MERGE (u:University {id: event.after.university_id}) MERGE (i)-[:BELONGS_TO]->(u)', event.op = 'd', 'MATCH (i:Institute {id: event.before.id}) DETACH DELETE i', event.op = 'u', 'MATCH (i:Institute {id: event.after.id}) SET i.name = event.after.name WITH i OPTIONAL MATCH (i)-[r:BELONGS_TO]->(:University) DELETE r WITH i MERGE (u:University {id: event.after.university_id}) MERGE (i)-[:BELONGS_TO]->(u)' ], '', {event: event}) YIELD value as institute RETURN institute",
    "neo4j.topic.cypher.postgres_server.public.department": "CALL apoc.do.case([ event.op = 'c', 'MERGE (d:Department {id: event.after.id}) SET d.name = event.after.name MERGE (i:Institute {id: event.after.institute_id}) MERGE (d)-[:BELONGS_TO]->(i)', event.op = 'd', 'MATCH (d:Department {id: event.before.id}) DETACH DELETE d', event.op = 'u', 'MATCH (d:Department {id: event.after.id}) SET d.name = event.after.name WITH d OPTIONAL MATCH (d)-[r:BELONGS_TO]->(:Institute) DELETE r WITH d MERGE (i:Institute {id: event.after.institute_id}) MERGE (d)-[:BELONGS_TO]->(i)' ], '', {event: event}) YIELD value as department RETURN department",
    "neo4j.topic.cypher.postgres_server.public.specialty": "CALL apoc.do.case([ event.op = 'c', 'MERGE (s:Specialty {id: event.after.id}) SET s.name = event.after.name MERGE (d:Department {id: event.after.department_id}) MERGE (s)-[:BELONGS_TO]->(d)', event.op = 'd', 'MATCH (s:Specialty {id: event.before.id}) DETACH DELETE s', event.op = 'u', 'MATCH (s:Specialty {id: event.after.id}) SET s.name = event.after.name WITH s OPTIONAL MATCH (s)-[r:BELONGS_TO]->(:Department) DELETE r WITH s MERGE (d:Department {id: event.after.department_id}) MERGE (s)-[:BELONGS_TO]->(d)' ], '', {event: event}) YIELD value as specialty RETURN specialty",
    "neo4j.topic.cypher.postgres_server.public.st_group": "CALL apoc.do.case([ event.op = 'c', 'MERGE (g:St_group {id: event.after.id}) SET g.name = event.after.name MERGE (s:Specialty {id: event.after.speciality_id}) MERGE (g)-[:BELONGS_TO]->(s)', event.op = 'd', 'MATCH (g:St_group {id: event.before.id}) DETACH DELETE g', event.op = 'u', 'MATCH (g:St_group {id: event.after.id}) SET g.name = event.after.name WITH g OPTIONAL MATCH (g)-[r:BELONGS_TO]->(:Specialty) DELETE r WITH g MERGE (s:Specialty {id: event.after.speciality_id}) MERGE (g)-[:BELONGS_TO]->(s)' ], '', {event: event}) YIELD value as st_group RETURN st_group",
    "neo4j.topic.cypher.postgres_server.public.course_of_lecture": "CALL apoc.do.case([ event.op = 'c', 'MERGE (c:Course_of_lecture {id: event.after.id}) SET c.name = event.after.name MERGE (d:Department {id: event.after.department_id}) MERGE (c)-[:IS_TAUGHT_BY]->(d) MERGE (s:Specialty {id: event.after.specialty_id}) MERGE (c)-[:FOR_SPECIALTY]->(s)', event.op = 'd', 'MATCH (c:Course_of_lecture {id: event.before.id}) DETACH DELETE c', event.op = 'u', 'MATCH (c:Course_of_lecture {id: event.after.id}) SET c.name = event.after.name WITH c OPTIONAL MATCH (c)-[r1:IS_TAUGHT_BY]->(:Department) DELETE r1 WITH c OPTIONAL MATCH (c)-[r2:FOR_SPECIALTY]->(:Specialty) DELETE r2 WITH c MERGE (d:Department {id: event.after.department_id}) MERGE (c)-[:IS_TAUGHT_BY]->(d) MERGE (s:Specialty {id: event.after.specialty_id}) MERGE (c)-[:FOR_SPECIALTY]->(s)' ], '', {event: event}) YIELD value as course_of_lecture RETURN course_of_lecture",
    "neo4j.topic.cypher.postgres_server.public.lecture": "CALL apoc.do.case([ event.op = 'c', 'MERGE (l:Lecture {id: event.after.id}) SET l.name = event.after.name MERGE (c:Course_of_lecture {id: event.after.course_of_lecture_id}) MERGE (l)-[:PART_OF]->(c)', event.op = 'd', 'MATCH (l:Lecture {id: event.before.id}) DETACH DELETE l', event.op = 'u', 'MATCH (l:Lecture {id: event.after.id}) SET l.name = event.after.name WITH l OPTIONAL MATCH (l)-[r:PART_OF]->(:Course_of_lecture) DELETE r WITH l MERGE (c:Course_of_lecture {id: event.after.course_of_lecture_id}) MERGE (l)-[:PART_OF]->(c)' ], '', {event: event}) YIELD value as lecture RETURN lecture",
    "neo4j.topic.cypher.postgres_server.public.material_of_lecture": "CALL apoc.do.case([ event.op = 'c', 'MERGE (m:Material_of_lecture {id: event.after.id}) SET m.name = event.after.name MERGE (l:Lecture {id: event.after.course_of_lecture_id}) MERGE (m)-[:BELONGS_TO]->(l)', event.op = 'd', 'MATCH (m:Material_of_lecture {id: event.before.id}) DETACH DELETE m', event.op = 'u', 'MATCH (m:Material_of_lecture {id: event.after.id}) SET m.name = event.after.name WITH m OPTIONAL MATCH (m)-[r:BELONGS_TO]->(:Lecture) DELETE r WITH m MERGE (l:Lecture {id: event.after.course_of_lecture_id}) MERGE (m)-[:BELONGS_TO]->(l)' ], '', {event: event}) YIELD value as material_of_lecture RETURN material_of_lecture",
    "neo4j.topic.cypher.postgres_server.public.students": "CALL apoc.do.case([ event.op = 'c', 'MERGE (s:Student {id: event.after.id}) SET s.name = event.after.name, s.age = event.after.age, s.mail = event.after.mail MERGE (g:St_group {id: event.after.group_id}) MERGE (s)-[:MEMBER_OF]->(g)', event.op = 'd', 'MATCH (s:Student {id: event.before.id}) DETACH DELETE s', event.op = 'u', 'MATCH (s:Student {id: event.after.id}) SET s.name = event.after.name, s.age = event.after.age, s.mail = event.after.mail WITH s OPTIONAL MATCH (s)-[r:MEMBER_OF]->(:St_group) DELETE r WITH s MERGE (g:St_group {id: event.after.group_id}) MERGE (s)-[:MEMBER_OF]->(g)' ], '', {event: event}) YIELD value as student RETURN student",
    "neo4j.topic.cypher.postgres_server.public.schedule": "CALL apoc.do.case([ event.op = 'c', 'MERGE (sch:Schedule {id: event.after.id}) SET sch.date = event.after.date MERGE (l:Lecture {id: event.after.lecture_id}) MERGE (g:St_group {id: event.after.group_id}) MERGE (sch)-[:FOR_GROUP]->(g) MERGE (l)-[:SCHEDULED_AT]->(sch)', event.op = 'd', 'MATCH (sch:Schedule {id: event.before.id}) DETACH DELETE sch', event.op = 'u', 'MATCH (sch:Schedule {id: event.after.id}) SET sch.date = event.after.date WITH sch OPTIONAL MATCH (sch)-[r1:FOR_GROUP]->(:St_group) DELETE r1 WITH sch OPTIONAL MATCH (sch)<-[r2:SCHEDULED_AT]-(:Lecture) DELETE r2 WITH sch MERGE (l:Lecture {id: event.after.lecture_id}) MERGE (g:St_group {id: event.after.group_id}) MERGE (sch)-[:FOR_GROUP]->(g) MERGE (l)-[:SCHEDULED_AT]->(sch)' ], '', {event: event}) YIELD value as schedule RETURN schedule"
  }
}
